<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON SERPENT</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Orbitron', sans-serif;
            background: #0a0a0f;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        h1 {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            margin-bottom: 15px;
            background: linear-gradient(90deg, #ff006e, #00f5ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .scores {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }
        .score-box { text-align: center; }
        .score-box .label { color: #666; font-size: 0.7rem; }
        .score-box .value { color: #00f5ff; font-size: 1.3rem; }
        .score-box.high .value { color: #ff006e; }
        .score-box.p2 .value { color: #ff6600; }
        .score-box.hidden { display: none; }
        canvas {
            border: 3px solid #00f5ff;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.4);
        }
        .info { margin-top: 15px; font-size: 0.7rem; color: #555; text-align: center; }
        .overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        .overlay.hidden { display: none; }
        .overlay h2 { color: #ff006e; font-size: 2rem; margin-bottom: 10px; }
        .overlay p { color: #00f5ff; font-size: 1.2rem; margin-bottom: 15px; }
        .overlay small { color: #666; font-size: 0.8rem; }
        .menu-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            padding: 12px 30px;
            margin: 8px;
            border: 2px solid #00f5ff;
            background: rgba(0,245,255,0.1);
            color: #00f5ff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .menu-btn:hover {
            background: #00f5ff;
            color: #0a0a0f;
            box-shadow: 0 0 20px rgba(0,245,255,0.5);
        }
        .menu-btn.orange { border-color: #ff6600; color: #ff6600; background: rgba(255,102,0,0.1); }
        .menu-btn.orange:hover { background: #ff6600; }
        .menu-btn.pink { border-color: #ff006e; color: #ff006e; background: rgba(255,0,110,0.1); }
        .menu-btn.pink:hover { background: #ff006e; }
        .winner { color: #39ff14; font-size: 1.5rem; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>NEON SERPENT</h1>
    <div class="scores">
        <div class="score-box"><div class="label">P1 SCORE</div><div class="value" id="score">0</div></div>
        <div class="score-box p2 hidden" id="p2Box"><div class="label">P2 SCORE</div><div class="value" id="p2score">0</div></div>
        <div class="score-box high"><div class="label">HIGH</div><div class="value" id="high">0</div></div>
    </div>
    <canvas id="game"></canvas>
    <div class="info" id="info">WASD / Arrows to move | Space to pause | R to restart</div>

    <!-- Main Menu -->
    <div class="overlay" id="menu">
        <h2>NEON SERPENT</h2>
        <p>Select Game Mode</p>
        <button class="menu-btn" onclick="startGame('solo')">SOLO</button>
        <button class="menu-btn orange" onclick="startGame('2p')">2 PLAYER</button>
        <button class="menu-btn pink" onclick="startGame('ai')">VS AI</button>
        <small style="margin-top:20px">P1: WASD/Arrows | P2: IJKL</small>
    </div>

    <!-- Game Over -->
    <div class="overlay hidden" id="gameOver">
        <div class="winner" id="winner"></div>
        <h2 id="gameOverTitle">GAME OVER</h2>
        <p id="finalScore">0</p>
        <button class="menu-btn" onclick="playAgain()">PLAY AGAIN</button>
        <button class="menu-btn pink" onclick="showMenu()">MENU</button>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const GRID = 20;

        let size, cells, mode = 'solo';
        let snake1, snake2, dir1, dir2, nextDir1, nextDir2;
        let food, score1, score2, highScore, running, paused;

        function resize() {
            size = Math.min(560, window.innerWidth - 40, window.innerHeight - 200);
            size = Math.floor(size / GRID) * GRID;
            canvas.width = canvas.height = size;
            cells = size / GRID;
        }

        function init() {
            resize();
            highScore = parseInt(localStorage.getItem('snakeHigh')) || 0;
            document.getElementById('high').textContent = highScore;
            draw();
        }

        function showMenu() {
            running = false;
            document.getElementById('menu').classList.remove('hidden');
            document.getElementById('gameOver').classList.add('hidden');
        }

        function startGame(m) {
            mode = m;
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('p2Box').classList.toggle('hidden', mode === 'solo');
            document.getElementById('info').textContent = mode === 'solo'
                ? 'WASD / Arrows to move | Space to pause | R to restart'
                : 'P1: WASD/Arrows | P2: IJKL | Space to pause';
            reset();
            loop();
        }

        function reset() {
            resize();
            const mid = Math.floor(cells / 2);

            // P1 starts left side
            snake1 = [{x: 4, y: mid}, {x: 3, y: mid}, {x: 2, y: mid}];
            dir1 = {x: 1, y: 0};
            nextDir1 = {x: 1, y: 0};

            // P2/AI starts right side
            snake2 = [{x: cells-5, y: mid}, {x: cells-4, y: mid}, {x: cells-3, y: mid}];
            dir2 = {x: -1, y: 0};
            nextDir2 = {x: -1, y: 0};

            score1 = score2 = 0;
            running = true;
            paused = false;

            document.getElementById('score').textContent = 0;
            document.getElementById('p2score').textContent = 0;
            document.getElementById('gameOver').classList.add('hidden');
            spawnFood();
        }

        function spawnFood() {
            const allSnake = [...snake1, ...snake2];
            do {
                food = {x: Math.floor(Math.random() * cells), y: Math.floor(Math.random() * cells)};
            } while (allSnake.some(s => s.x === food.x && s.y === food.y));
        }

        function loop() {
            setTimeout(() => {
                if (!running) return;
                requestAnimationFrame(loop);
                if (paused) { draw(); return; }
                if (mode === 'ai') updateAI();
                update();
                draw();
            }, 100);
        }

        function updateAI() {
            const head = snake2[0];
            const moves = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];

            // Filter out reverse direction and dangerous moves
            const validMoves = moves.filter(m => {
                if (m.x === -dir2.x && m.y === -dir2.y) return false;
                const newX = head.x + m.x;
                const newY = head.y + m.y;
                if (newX < 0 || newX >= cells || newY < 0 || newY >= cells) return false;
                return !snake2.some(s => s.x === newX && s.y === newY) &&
                       !snake1.some(s => s.x === newX && s.y === newY);
            });

            if (validMoves.length === 0) return;

            // Pick move closest to food
            let best = validMoves[0], bestDist = Infinity;
            validMoves.forEach(m => {
                const newX = head.x + m.x;
                const newY = head.y + m.y;
                const dist = Math.abs(food.x - newX) + Math.abs(food.y - newY);
                if (dist < bestDist) { bestDist = dist; best = m; }
            });

            nextDir2 = best;
        }

        function update() {
            dir1 = {...nextDir1};
            if (mode !== 'solo') dir2 = {...nextDir2};

            const alive1 = moveSnake(1);
            const alive2 = mode !== 'solo' ? moveSnake(2) : true;

            if (mode === 'solo') {
                if (!alive1) endGame(null);
            } else {
                if (!alive1 && !alive2) endGame('draw');
                else if (!alive1) endGame(2);
                else if (!alive2) endGame(1);
            }
        }

        function moveSnake(player) {
            const snake = player === 1 ? snake1 : snake2;
            const dir = player === 1 ? dir1 : dir2;
            const other = player === 1 ? snake2 : snake1;

            const head = {
                x: snake[0].x + dir.x,
                y: snake[0].y + dir.y
            };

            // Wall collision
            if (head.x < 0 || head.x >= cells || head.y < 0 || head.y >= cells) return false;

            // Self collision
            if (snake.some(s => s.x === head.x && s.y === head.y)) return false;

            // Other snake collision (in multiplayer)
            if (mode !== 'solo' && other.some(s => s.x === head.x && s.y === head.y)) return false;

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                if (player === 1) {
                    score1 += 10;
                    document.getElementById('score').textContent = score1;
                    if (score1 > highScore) {
                        highScore = score1;
                        localStorage.setItem('snakeHigh', highScore);
                        document.getElementById('high').textContent = highScore;
                    }
                } else {
                    score2 += 10;
                    document.getElementById('p2score').textContent = score2;
                }
                spawnFood();
            } else {
                snake.pop();
            }

            return true;
        }

        function playAgain() {
            reset();
            loop();
        }

        function endGame(winner) {
            running = false;
            const winnerEl = document.getElementById('winner');
            const titleEl = document.getElementById('gameOverTitle');
            const scoreEl = document.getElementById('finalScore');

            if (mode === 'solo') {
                winnerEl.textContent = '';
                titleEl.textContent = 'GAME OVER';
                scoreEl.textContent = score1;
            } else if (winner === 'draw') {
                winnerEl.textContent = 'DRAW!';
                titleEl.textContent = '';
                scoreEl.textContent = `P1: ${score1} | P2: ${score2}`;
            } else if (winner === 1) {
                winnerEl.textContent = 'PLAYER 1 WINS!';
                titleEl.textContent = '';
                scoreEl.textContent = `P1: ${score1} | P2: ${score2}`;
            } else {
                winnerEl.textContent = mode === 'ai' ? 'AI WINS!' : 'PLAYER 2 WINS!';
                titleEl.textContent = '';
                scoreEl.textContent = `P1: ${score1} | P2: ${score2}`;
            }

            document.getElementById('gameOver').classList.remove('hidden');
        }

        function draw() {
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, size, size);

            // Grid
            ctx.strokeStyle = 'rgba(0,245,255,0.05)';
            for (let i = 0; i <= cells; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID, 0); ctx.lineTo(i * GRID, size);
                ctx.moveTo(0, i * GRID); ctx.lineTo(size, i * GRID);
                ctx.stroke();
            }

            // Food
            ctx.fillStyle = '#39ff14';
            ctx.shadowColor = '#39ff14';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(food.x * GRID + GRID/2, food.y * GRID + GRID/2, GRID/2 - 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Snake 1 (cyan)
            drawSnake(snake1, '#00f5ff');

            // Snake 2 (orange) - only in multiplayer
            if (mode !== 'solo') drawSnake(snake2, '#ff6600');
        }

        function drawSnake(snake, color) {
            snake.forEach((s, i) => {
                ctx.fillStyle = i === 0 ? color : color + (Math.floor((1 - i * 0.03) * 255)).toString(16).padStart(2,'0');
                ctx.shadowColor = color;
                ctx.shadowBlur = i === 0 ? 12 : 5;
                ctx.beginPath();
                ctx.roundRect(s.x * GRID + 1, s.y * GRID + 1, GRID - 2, GRID - 2, 4);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        document.addEventListener('keydown', e => {
            // P1: WASD and Arrows
            const p1Keys = {
                ArrowUp: {x:0,y:-1}, w: {x:0,y:-1}, W: {x:0,y:-1},
                ArrowDown: {x:0,y:1}, s: {x:0,y:1}, S: {x:0,y:1},
                ArrowLeft: {x:-1,y:0}, a: {x:-1,y:0}, A: {x:-1,y:0},
                ArrowRight: {x:1,y:0}, d: {x:1,y:0}, D: {x:1,y:0}
            };
            if (p1Keys[e.key] && (p1Keys[e.key].x !== -dir1.x || p1Keys[e.key].y !== -dir1.y)) {
                nextDir1 = p1Keys[e.key];
                e.preventDefault();
            }

            // P2: IJKL (only in 2-player mode)
            if (mode === '2p') {
                const p2Keys = {
                    i: {x:0,y:-1}, I: {x:0,y:-1},
                    k: {x:0,y:1}, K: {x:0,y:1},
                    j: {x:-1,y:0}, J: {x:-1,y:0},
                    l: {x:1,y:0}, L: {x:1,y:0}
                };
                if (p2Keys[e.key] && (p2Keys[e.key].x !== -dir2.x || p2Keys[e.key].y !== -dir2.y)) {
                    nextDir2 = p2Keys[e.key];
                }
            }

            if (e.key === ' ') {
                e.preventDefault();
                if (running) paused = !paused;
            }
            if ((e.key === 'r' || e.key === 'R') && running) reset();
        });

        canvas.addEventListener('click', () => { if (!running) playAgain(); });

        let touchStart = null;
        canvas.addEventListener('touchstart', e => { touchStart = {x: e.touches[0].clientX, y: e.touches[0].clientY}; e.preventDefault(); }, {passive: false});
        canvas.addEventListener('touchend', e => {
            if (!touchStart) return;
            const dx = e.changedTouches[0].clientX - touchStart.x;
            const dy = e.changedTouches[0].clientY - touchStart.y;
            if (Math.abs(dx) < 20 && Math.abs(dy) < 20) return;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0 && dir1.x !== -1) nextDir1 = {x:1, y:0};
                else if (dx < 0 && dir1.x !== 1) nextDir1 = {x:-1, y:0};
            } else {
                if (dy > 0 && dir1.y !== -1) nextDir1 = {x:0, y:1};
                else if (dy < 0 && dir1.y !== 1) nextDir1 = {x:0, y:-1};
            }
        }, {passive: false});

        window.addEventListener('resize', resize);
        init();
    </script>
</body>
</html>
